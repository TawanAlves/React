export function timeFix () {
  const time = new Date()
  const hour = time.getHours()
  return hour < 9 ? '早上好' : hour <= 11 ? '上午好' : hour <= 13 ? '中午好' : hour < 20 ? '下午好' : '晚上好'
}

export function welcome () {
  const arr = ['休息一会儿吧', '准备吃什么呢?', '我猜你可能累了']
  const index = Math.floor(Math.random() * arr.length)
  return arr[index]
}

/**
 * 触发 window.resize
 */
export function triggerWindowResizeEvent () {
  const event = document.createEvent('HTMLEvents')
  event.initEvent('resize', true, true)
  event.eventType = 'message'
  window.dispatchEvent(event)
}

export function handleScrollHeader (callback) {
  let timer = 0

  let beforeScrollTop = window.pageYOffset
  callback = callback || function () {
  }
  window.addEventListener(
    'scroll',
    event => {
      clearTimeout(timer)
      timer = setTimeout(() => {
        let direction = 'up'
        const afterScrollTop = window.pageYOffset
        const delta = afterScrollTop - beforeScrollTop
        if (delta === 0) {
          return false
        }
        direction = delta > 0 ? 'down' : 'up'
        callback(direction)
        beforeScrollTop = afterScrollTop
      }, 50)
    },
    false
  )
}

export function isIE () {
  const bw = window.navigator.userAgent
  const compare = (s) => bw.indexOf(s) >= 0
  const ie11 = (() => 'ActiveXObject' in window)()
  return compare('MSIE') || ie11
}

/**
 * Remove loading animate
 * @param id parent element id or class
 * @param timeout
 */
export function removeLoadingAnimate (id = '', timeout = 1500) {
  if (id === '') {
    return
  }
  setTimeout(() => {
    document.body.removeChild(document.getElementById(id))
  }, timeout)
}

/**
 * 动态插入css
 */
export const loadStyle = url => {
  const link = document.createElement('link')
  link.type = 'text/css'
  link.rel = 'stylesheet'
  link.href = url
  const head = document.getElementsByTagName('head')[0]
  head.appendChild(link)
}

export function fileToBase64 (file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader()
    reader.readAsDataURL(file)
    reader.onload = () => resolve(reader.result)
    reader.onerror = error => reject(error)
  })
}

export const isNotNullOrUndefined = (value) => {
  if (typeof (value) === 'undefined') {
    return false
  } else if (!value && typeof (value) !== 'undefined' && value !== 0) {
    return false
  } else {
    return true
  }
}

export const getUUID = () => {
  function S4 () {
    return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1)
  }

  return (S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4())
}
/**
 * 遍历树节点
 * 查找指定节点的所有父节点
 */
export const tranverseTree = (arr1, id) => {
  // 返回数据集合
  var temp = []
  // 声明递归函数
  var forFn = function (arr, id) {
    // 遍历树
    for (let i = 0; i < arr.length; i++) {
      const item = arr[i]
      if (item.id === id) {
        // 查找到指定节点加入集合
        temp.push(item)
        // 查找其父节点
        forFn(arr1, item.parentId)
        // 不必向下遍历，跳出循环
        break
      } else {
        if (item.children) {
          // 向下查找到id
          forFn(item.children, id)
        }
      }
    }
  }
  // 调用函数
  forFn(arr1, id)
  // 返回结果
  return temp
}

/**
 * 获取指定节点在树中的层级
 * @param treeData
 * @param nodeId
 * @returns {number}
 */
export const getNodeLevel = function (treeData, nodeId) {
  const nodes = tranverseTree(treeData, nodeId)
  return nodes.length
}

/**
 * 查找指定节点的所有孩子节点
 * @param treeData
 * @param nodeId
 */
export const getChildNodesIds = function (treeData, nodeId) {
  var theNode = null
  const forFn = function (arr, id) {
    // 遍历树
    for (let i = 0; i < arr.length; i++) {
      const item = arr[i]
      if (item.id === id) {
        theNode = item
        break
      } else {
        if (item.children) {
          // 向下查找到id
          forFn(item.children, id)
        }
      }
    }
  }
  // 调用函数
  forFn(treeData, nodeId)

  const temp = [nodeId]
  if (!theNode) {
    temp.join(',')
  }
  const traverseChild = function (arr) {
    if (!arr) {
      return
    }
    if (arr.children) {
      for (let i = 0; i < arr.children.length; i++) {
        temp.push(arr.children[i].id)
        traverseChild(arr.children[i])
      }
    }
  }
  traverseChild(theNode)
  return temp.join(',')
}

/**
 * @name  getTableData
 * @desc  纯JS前端分页方法
 * @param  {Number} page 当前页码，默认1
 * @param  {Number} pageSize 每页最多显示条数，默认10
 * @param  {Array} totalData 总的数据集，默认为空数组
 * @return {Object} {
    data, //当前页展示数据，数组
    page, //当前页码
    pageSize, //每页最多显示条数
    length, //总的数据条数
  }
**/
export const getTableData = (page = 1, pageSize = 10, totalData = []) => {
  const { length } = totalData
  const tableData = {
    data: [],
    page,
    pageSize,
    length
  }
  if (pageSize >= length) { // pageSize大于等于总数据长度，说明只有1页数据或没有数据
    tableData.data = totalData
    tableData.page = 1// 直接取第一页
  } else { // pageSize小于总数据长度，数据多余1页
    const num = pageSize * (page - 1)// 计算当前页（不含）之前的所有数据总条数
    if (num < length) { // 如果当前页之前所有数据总条数小于（不能等于）总的数据集长度，则说明当前页码没有超出最大页码
      const startIndex = num// 当前页第一条数据在总数据集中的索引
      const endIndex = num + pageSize - 1// 当前页最后一条数据索引
      tableData.data = totalData.filter((_, index) => index >= startIndex && index <= endIndex)// 当前页数据条数小于每页最大条数时，也按最大条数范围筛取数据
    } else { // 当前页码超出最大页码，则计算实际最后一页的page，自动返回最后一页数据
      const size = parseInt(length / pageSize) // 取商
      const rest = length % pageSize // 取余数
      if (rest > 0) { // 余数大于0，说明实际最后一页数据不足pageSize，应该取size+1为最后一条的页码
        tableData.page = size + 1// 当前页码重置，取size+1
        tableData.data = totalData.filter((_, index) => index >= (pageSize * size) && index <= length)
      } else if (rest === 0) { // 余数等于0，最后一页数据条数正好是pageSize
        tableData.page = size// 当前页码重置，取size
        tableData.data = totalData.filter((_, index) => index >= (pageSize * (size - 1)) && index <= length)
      } // 注：余数不可能小于0
    }
  }
  return tableData
}

/**
 * 根据开始时间和结束时间获取时长（单位:分钟）
 * @param date1
 * @param date2
 * @returns {number}
 */
export function getMinutesByDateRange (date1, date2) {
  const endTime = new Date(date2)
  const startTime = new Date(date1)
  const difference = endTime.getTime() - startTime.getTime()
  return Math.round(difference / 60000)
}

/**
 * 将秒转换成具体的XX时XX分XX秒
 * @param minutes
 */
export function formatTimeBySeconds (time) {
  if (!isNotNullOrUndefined(time)) {
    return ''
  }
  const h = parseInt(time / 3600)
  const m = parseInt((time % 3600) / 60)
  const s = parseInt((time % 3600) % 60)
  return `${h}小时${m}分钟${s}秒`
}
